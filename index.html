<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSV Data Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root {
        --bg: #ffffff;
        --panel: #ffffff;
        --border: #dbe4f0;
        --text: #1f2a44;
        --muted: #5f6f8b;
        --primary: #1665d8;
        --primary-dark: #0f4fb0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      .app-shell {
        min-height: 100vh;
        padding: 32px 20px;
        display: flex;
        justify-content: center;
      }

      .container {
        width: min(980px, 100%);
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        box-shadow: 0 12px 28px rgba(16, 42, 67, 0.08);
        padding: 28px;
      }

      h1 {
        margin: 0;
        font-size: 30px;
        color: #123a7d;
      }

      .subtitle {
        margin-top: 8px;
        color: var(--muted);
      }

      .controls-grid {
        margin-top: 24px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 16px;
      }

      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 16px;
        background: #fff;
      }

      .card h2 {
        margin: 0 0 12px 0;
        font-size: 18px;
        color: #184f9f;
      }

      label {
        display: block;
        font-size: 13px;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 6px;
      }

      input[type="file"],
      input[type="password"],
      textarea {
        width: 100%;
        border: 1px solid #c8d5ea;
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 14px;
        color: var(--text);
        outline: none;
      }

      input:focus,
      textarea:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(22, 101, 216, 0.15);
      }

      textarea {
        min-height: 96px;
        resize: vertical;
      }

      .button-row {
        margin-top: 12px;
        display: flex;
        gap: 8px;
      }

      button {
        border: none;
        border-radius: 10px;
        background: var(--primary);
        color: #fff;
        padding: 10px 14px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      button:hover {
        background: var(--primary-dark);
      }

      button:disabled {
        cursor: not-allowed;
        background: #89ade3;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
      }

      th,
      td {
        border: 1px solid #d4e0f2;
        padding: 8px;
        font-size: 13px;
        text-align: left;
      }

      th {
        background: #eef4ff;
      }

      .status-error {
        margin-top: 12px;
        border-radius: 10px;
        padding: 10px;
        background: #ffe9ec;
        color: #9f1c2e;
        border: 1px solid #ffc6cd;
      }

      .spinner-overlay {
        margin-top: 18px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      .spinner {
        width: 28px;
        height: 28px;
        border: 4px solid #c7dcff;
        border-top: 4px solid var(--primary);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .viz-area {
        margin-top: 24px;
      }

      .chart-wrap {
        border: 1px solid #d9e4f3;
        border-radius: 12px;
        padding: 16px;
      }

      .chart-title {
        margin: 0 0 12px 0;
        font-size: 16px;
        color: #184f9f;
      }

      .count-card {
        border: 1px solid #cde0ff;
        border-radius: 12px;
        background: #f4f8ff;
        padding: 16px;
      }

      .count-value {
        font-size: 34px;
        font-weight: 700;
      }

      .muted {
        color: var(--muted);
        font-size: 13px;
      }

      .helper {
        margin-top: 10px;
        color: var(--muted);
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState } = React;

      function parseCsv(text) {
        const lines = text.replace(/\r/g, "").split("\n").filter((line) => line.trim().length > 0);
        if (!lines.length) return { headers: [], rows: [] };

        const parseLine = (line) => {
          const result = [];
          let current = "";
          let inQuotes = false;

          for (let i = 0; i < line.length; i += 1) {
            const char = line[i];
            const next = line[i + 1];

            if (char === '"' && inQuotes && next === '"') {
              current += '"';
              i += 1;
              continue;
            }

            if (char === '"') {
              inQuotes = !inQuotes;
              continue;
            }

            if (char === "," && !inQuotes) {
              result.push(current.trim());
              current = "";
              continue;
            }

            current += char;
          }

          result.push(current.trim());
          return result;
        };

        const headers = parseLine(lines[0]);
        const rows = lines.slice(1).map(parseLine);
        return { headers, rows };
      }

      function BarChart({ data }) {
        const maxVal = Math.max(...data.values, 1);
        return (
          <div className="chart-wrap">
            <h3 className="chart-title">{data.title || "Bar Chart"}</h3>
            <svg width="100%" height="280" viewBox="0 0 720 280" role="img" aria-label={data.title || "Bar chart"}>
              <line x1="48" y1="18" x2="48" y2="238" stroke="#8FA4C2" strokeWidth="1" />
              <line x1="48" y1="238" x2="680" y2="238" stroke="#8FA4C2" strokeWidth="1" />
              {data.values.map((v, i) => {
                const barW = 560 / Math.max(data.values.length, 1);
                const x = 62 + i * barW;
                const h = (Math.max(0, Number(v) || 0) / maxVal) * 190;
                const y = 238 - h;
                return (
                  <g key={`${data.labels[i]}-${i}`}>
                    <rect x={x} y={y} width={Math.max(12, barW - 8)} height={h} fill="#1665d8" rx="4" />
                    <text x={x + (Math.max(12, barW - 8)) / 2} y={252} textAnchor="middle" fontSize="11" fill="#2d405f">
                      {String(data.labels[i]).slice(0, 10)}
                    </text>
                    <text x={x + (Math.max(12, barW - 8)) / 2} y={Math.max(14, y - 6)} textAnchor="middle" fontSize="11" fill="#2d405f">
                      {Number(v).toLocaleString()}
                    </text>
                  </g>
                );
              })}
            </svg>
          </div>
        );
      }

      function LineChart({ data }) {
        const maxVal = Math.max(...data.values, 1);
        const minVal = Math.min(...data.values, 0);
        const spread = maxVal - minVal || 1;

        const points = data.values
          .map((v, i) => {
            const x = 60 + (i * 580) / Math.max(data.values.length - 1, 1);
            const y = 220 - ((Number(v) - minVal) / spread) * 170;
            return `${x},${y}`;
          })
          .join(" ");

        return (
          <div className="chart-wrap">
            <h3 className="chart-title">{data.title || "Line Chart"}</h3>
            <svg width="100%" height="280" viewBox="0 0 720 280" role="img" aria-label={data.title || "Line chart"}>
              <line x1="48" y1="18" x2="48" y2="238" stroke="#8FA4C2" strokeWidth="1" />
              <line x1="48" y1="238" x2="680" y2="238" stroke="#8FA4C2" strokeWidth="1" />
              <polyline fill="none" stroke="#1665d8" strokeWidth="3" points={points} />
              {data.values.map((v, i) => {
                const x = 60 + (i * 580) / Math.max(data.values.length - 1, 1);
                const y = 220 - ((Number(v) - minVal) / spread) * 170;
                return (
                  <g key={`${data.labels[i]}-${i}`}>
                    <circle cx={x} cy={y} r="4" fill="#1665d8" />
                    <text x={x} y={252} textAnchor="middle" fontSize="11" fill="#2d405f">
                      {String(data.labels[i]).slice(0, 10)}
                    </text>
                  </g>
                );
              })}
            </svg>
          </div>
        );
      }

      async function generateAnalysisScript({ apiKey, headers, rows, userRequest }) {
        const sampleRows = rows.slice(0, 5);
        const sampleCsvLines = [headers.join(","), ...sampleRows.map((row) => row.join(","))].join("\n");
        const prompt = `You are an expert data analyst and JavaScript engineer.

Write JavaScript that analyzes CSV data based on user instructions.
The data is provided as:\n- headers: string[]\n- rows: any[][] (array of row values in header order)

User analysis request:\n${userRequest}

Sample of the first 5 lines of data:\n${sampleCsvLines}

Output requirements:
- Your code MUST assign the final output to a variable named analysisResult.
- The shape must be:
analysisResult = {
  type: 'bar_chart' | 'line_chart' | 'table' | 'count',
  data: <appropriate structure>,
  config: <optional configuration object>
};

Data structure requirements by type:
- bar_chart: { labels: string[], values: number[], title?: string }
- line_chart: { labels: string[], values: number[], title?: string }
- table: { headers: string[], rows: any[][] }
- count: { value: number, label?: string }

Additional requirements:
- Choose the most appropriate visualization type based on the analysis
- For numeric aggregations (sum, average, count), use 'count' type
- For comparisons between categories, use 'bar_chart'
- For trends over time, use 'line_chart'
- For detailed data inspection or pivot tables use 'table'
- Include meaningful labels and titles where appropriate
- Handle edge cases gracefully (empty data, missing values, etc.)

Coding constraints:
- Use only plain JavaScript.
- Do not use external libraries.
- Assume headers and rows already exist.
- Return only JavaScript code, no markdown, no explanations.`;

        const payload = {
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 16384
          }
        };

        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash:generateContent?key=${encodeURIComponent(apiKey)}`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          }
        );

        if (!response.ok) {
          const msg = await response.text();
          throw new Error(`Gemini API error: ${response.status} ${msg}`);
        }

        const data = await response.json();
        const code = data?.candidates?.[0]?.content?.parts?.map((p) => p.text).join("\n")?.trim();

        if (!code) {
          throw new Error("Gemini API returned an empty response.");
        }

        return code;
      }

      function executeAnalysisScript(script, headers, rows) {
        let analysisResult;
        const runner = new Function(
          "headers",
          "rows",
          `"use strict";\n${script}\n; return typeof analysisResult !== 'undefined' ? analysisResult : null;`
        );
        analysisResult = runner(headers, rows);

        if (!analysisResult || !analysisResult.type || !analysisResult.data) {
          throw new Error("Generated script did not create a valid analysisResult object.");
        }

        return analysisResult;
      }

      function App() {
        const [apiKey, setApiKey] = useState("");
        const [csvData, setCsvData] = useState({ headers: [], rows: [] });
        const [previewRows, setPreviewRows] = useState([]);
        const [analysisPrompt, setAnalysisPrompt] = useState("");
        const [analysisResult, setAnalysisResult] = useState(null);
        const [loadingStage, setLoadingStage] = useState(null);
        const [error, setError] = useState("");

        const canRunAnalysis = useMemo(
          () => apiKey.trim() && csvData.headers.length && analysisPrompt.trim() && !loadingStage,
          [apiKey, csvData, analysisPrompt, loadingStage]
        );

        async function onCsvUpload(event) {
          const file = event.target.files?.[0];
          if (!file) return;

          try {
            setError("");
            setAnalysisResult(null);
            const text = await file.text();
            const parsed = parseCsv(text);
            setCsvData(parsed);
            setPreviewRows(parsed.rows.slice(0, 5));
          } catch (err) {
            setError(`Failed to parse CSV: ${err.message}`);
          }
        }

        async function runAnalysis() {
          try {
            setError("");
            setAnalysisResult(null);
            setLoadingStage("planning");

            const script = await generateAnalysisScript({
              apiKey,
              headers: csvData.headers,
              rows: csvData.rows,
              userRequest: analysisPrompt
            });

            setLoadingStage("calculating");
            await new Promise((resolve) => setTimeout(resolve, 150));

            const result = executeAnalysisScript(script, csvData.headers, csvData.rows);
            setAnalysisResult(result);
            setLoadingStage(null);
          } catch (err) {
            setLoadingStage(null);
            setError(err.message || "Analysis failed.");
          }
        }

        function renderResult() {
          if (!analysisResult) return null;

          const { type, data } = analysisResult;

          if (type === "bar_chart") {
            return <BarChart data={data} />;
          }

          if (type === "line_chart") {
            return <LineChart data={data} />;
          }

          if (type === "table") {
            return (
              <div className="chart-wrap">
                <h3 className="chart-title">{data.title || "Table Result"}</h3>
                <table>
                  <thead>
                    <tr>
                      {(data.headers || []).map((h) => (
                        <th key={h}>{h}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {(data.rows || []).map((row, idx) => (
                      <tr key={idx}>
                        {row.map((cell, cIdx) => (
                          <td key={`${idx}-${cIdx}`}>{String(cell ?? "")}</td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            );
          }

          if (type === "count") {
            return (
              <div className="count-card">
                <div className="muted">{data.label || "Computed value"}</div>
                <div className="count-value">{Number(data.value ?? 0).toLocaleString()}</div>
              </div>
            );
          }

          return <div className="status-error">Unsupported analysis type: {String(type)}</div>;
        }

        return (
          <div className="app-shell">
            <main className="container">
              <h1>CSV Data Visualizer</h1>
              <p className="subtitle">Upload CSV files, describe your analysis, and get dynamic results powered by Gemini.</p>

              <div className="controls-grid">
                <section className="card">
                  <h2>1) Data Source</h2>
                  <label htmlFor="csv-upload">Upload CSV file</label>
                  <input id="csv-upload" type="file" accept=".csv,text/csv" onChange={onCsvUpload} />
                  <p className="helper">The first row is treated as column headers.</p>

                  {csvData.headers.length > 0 && (
                    <>
                      <p className="helper">
                        Loaded <strong>{csvData.rows.length}</strong> rows with <strong>{csvData.headers.length}</strong> columns.
                      </p>
                      <table>
                        <thead>
                          <tr>
                            {csvData.headers.map((h) => (
                              <th key={h}>{h}</th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {previewRows.map((row, idx) => (
                            <tr key={idx}>
                              {csvData.headers.map((_, cIdx) => (
                                <td key={`${idx}-${cIdx}`}>{String(row[cIdx] ?? "")}</td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </>
                  )}
                </section>

                <section className="card">
                  <h2>2) Analysis Setup</h2>
                  <label htmlFor="api-key">Gemini API Key</label>
                  <input
                    id="api-key"
                    type="password"
                    placeholder="Enter your Gemini API key"
                    value={apiKey}
                    onChange={(e) => setApiKey(e.target.value)}
                  />

                  <label htmlFor="analysis-prompt" style={{ marginTop: "12px" }}>
                    Describe the analysis you want
                  </label>
                  <textarea
                    id="analysis-prompt"
                    placeholder="Example: Compare total sales by region and show a bar chart"
                    value={analysisPrompt}
                    onChange={(e) => setAnalysisPrompt(e.target.value)}
                  />

                  <div className="button-row">
                    <button disabled={!canRunAnalysis} onClick={runAnalysis}>
                      Run Analysis
                    </button>
                  </div>

                  {loadingStage && (
                    <div className="spinner-overlay" aria-live="polite">
                      <div className="spinner" />
                      <div className="muted">{loadingStage === "planning" ? "Planning analysis" : "Calculating results"}</div>
                    </div>
                  )}

                  {error && <div className="status-error">{error}</div>}
                </section>
              </div>

              <section className="viz-area">
                <h2>3) Analysis Output</h2>
                {analysisResult ? renderResult() : <p className="muted">No analysis output yet. Upload a CSV and run an analysis request.</p>}
              </section>
            </main>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
